<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Visualizer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      touch-action: none;
      /* Prevent browser handling of touch gestures */
    }

    canvas {
      display: block;
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      z-index: 10;
    }

    .control-button {
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      margin: 0 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
    }

    #info {
      position: absolute;
      top: 15px;
      left: 15px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      font-size: 14px;
    }

    /* Help overlay */
    #help-overlay {
      position: absolute;
      top: 15px;
      right: 15px;
    }

    #help-button {
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      font-size: 20px;
      font-weight: bold;
    }

    #help-content {
      display: none;
      position: absolute;
      top: 50px;
      right: 0;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      width: 250px;
      font-size: 14px;
    }

    .help-row {
      display: flex;
      margin-bottom: 10px;
      align-items: center;
    }

    .gesture-icon {
      flex: 0 0 40px;
      height: 40px;
      margin-right: 10px;
      background: #f0f0f0;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    /* Loading indicator */
    #loading {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    #loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }
  </style>
  <!-- Load Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
  <!-- Loading screen -->
  <div id="loading">
    <div id="loading-spinner"></div>
    <div>Loading visualization...</div>
  </div>

  <div id="info">
    <div>Items: <span id="itemCount">0</span></div>
    <div>Current: <span id="currentItem">0</span></div>
  </div>

  <div id="help-overlay">
    <button id="help-button">?</button>
    <div id="help-content">
      <h3 style="margin-top: 0;">Touch Controls</h3>
      <div class="help-row">
        <div class="gesture-icon">‚òùÔ∏è</div>
        <div>One finger drag to rotate</div>
      </div>
      <div class="help-row">
        <div class="gesture-icon">üëÜüëÜ</div>
        <div>Two finger pinch to zoom</div>
      </div>
      <div class="help-row">
        <div class="gesture-icon">üëÜüëÜ</div>
        <div>Two finger drag to pan</div>
      </div>
      <div class="help-row">
        <div class="gesture-icon">‚ñ∂Ô∏è</div>
        <div>Play animation</div>
      </div>
      <div class="help-row">
        <div class="gesture-icon">‚è∏Ô∏è</div>
        <div>Pause animation</div>
      </div>
      <div class="help-row">
        <div class="gesture-icon">‚èÆÔ∏è</div>
        <div>Reset animation</div>
      </div>
    </div>
  </div>

  <div id="controls">
    <button class="control-button" id="rewind-button">‚èÆÔ∏è</button>
    <button class="control-button" id="play-button">‚ñ∂Ô∏è</button>
    <button class="control-button" id="pause-button">‚è∏Ô∏è</button>
  </div>

  <script>
    // Make sure THREE is fully loaded before using it
    document.addEventListener('DOMContentLoaded', function () {
      // Mobile Touch Controls Implementation
      class TouchControls {
        constructor(camera, domElement) {
          this.camera = camera;
          this.domElement = domElement;
          this.enabled = true;
          this.target = new THREE.Vector3(20, 20, 20); // Center of the container

          // Current position in spherical coordinates
          this.spherical = new THREE.Spherical();
          this.sphericalDelta = new THREE.Spherical();

          // Pan settings
          this.panOffset = new THREE.Vector3();
          this.panSpeed = 0.3;

          // Zoom settings
          this.scale = 1;
          this.zoomSpeed = 0.1;
          this.minDistance = 10;
          this.maxDistance = 200;

          // State tracking
          this.isRotating = false;
          this.isPanning = false;
          this.isZooming = false;
          this.rotateStart = { x: 0, y: 0 };
          this.rotateEnd = { x: 0, y: 0 };
          this.panStart = { x: 0, y: 0 };
          this.panEnd = { x: 0, y: 0 };
          this.zoomDistStart = 0;

          // Bind event handlers
          this.onTouchStart = this.onTouchStart.bind(this);
          this.onTouchMove = this.onTouchMove.bind(this);
          this.onTouchEnd = this.onTouchEnd.bind(this);

          // Add event listeners
          this.domElement.addEventListener('touchstart', this.onTouchStart, false);
          this.domElement.addEventListener('touchmove', this.onTouchMove, false);
          this.domElement.addEventListener('touchend', this.onTouchEnd, false);

          // Initialize spherical coordinates
          this.updateSpherical();
        }

        updateSpherical() {
          const offset = this.camera.position.clone().sub(this.target);
          this.spherical.setFromVector3(offset);
        }

        onTouchStart(event) {
          if (!this.enabled) return;
          event.preventDefault();

          switch (event.touches.length) {
            case 1: // Single touch - rotate
              this.isRotating = true;
              this.rotateStart.x = event.touches[0].pageX;
              this.rotateStart.y = event.touches[0].pageY;
              break;

            case 2: // Two touches - pan or zoom
              const dx = event.touches[0].pageX - event.touches[1].pageX;
              const dy = event.touches[0].pageY - event.touches[1].pageY;
              this.zoomDistStart = Math.sqrt(dx * dx + dy * dy);

              // Set up for panning
              this.isPanning = true;
              this.panStart.x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
              this.panStart.y = (event.touches[0].pageY + event.touches[1].pageY) / 2;

              // Also set up for zooming
              this.isZooming = true;
              break;
          }
        }

        onTouchMove(event) {
          if (!this.enabled) return;
          event.preventDefault();

          if (this.isRotating && event.touches.length === 1) {
            // Handle rotation
            this.rotateEnd.x = event.touches[0].pageX;
            this.rotateEnd.y = event.touches[0].pageY;

            // Calculate rotation
            const rotateDelta = {
              x: this.rotateEnd.x - this.rotateStart.x,
              y: this.rotateEnd.y - this.rotateStart.y
            };

            // Adjust rotation speed
            const rotateSpeed = 0.003;

            // Apply rotation
            this.sphericalDelta.theta -= rotateDelta.x * rotateSpeed;
            this.sphericalDelta.phi -= rotateDelta.y * rotateSpeed;

            // Update start position for next frame
            this.rotateStart.x = this.rotateEnd.x;
            this.rotateStart.y = this.rotateEnd.y;

            this.update();
          } else if (event.touches.length === 2) {
            // Handle zooming
            if (this.isZooming) {
              const dx = event.touches[0].pageX - event.touches[1].pageX;
              const dy = event.touches[0].pageY - event.touches[1].pageY;
              const distance = Math.sqrt(dx * dx + dy * dy);

              const ratio = distance / this.zoomDistStart;
              this.dolly(ratio);

              // Update the start distance for next frame
              this.zoomDistStart = distance;
            }

            // Handle panning
            if (this.isPanning) {
              this.panEnd.x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
              this.panEnd.y = (event.touches[0].pageY + event.touches[1].pageY) / 2;

              const panDelta = {
                x: this.panEnd.x - this.panStart.x,
                y: this.panEnd.y - this.panStart.y
              };

              this.pan(panDelta.x, panDelta.y);

              // Update start position for next frame
              this.panStart.x = this.panEnd.x;
              this.panStart.y = this.panEnd.y;
            }

            this.update();
          }
        }

        onTouchEnd(event) {
          this.isRotating = false;
          this.isPanning = false;
          this.isZooming = false;
        }

        pan(deltaX, deltaY) {
          const offset = new THREE.Vector3();
          const element = this.domElement;

          // Calculate how far you're panning based on screen width/height
          offset.x = -2 * deltaX * this.panSpeed / element.clientWidth;
          offset.y = 2 * deltaY * this.panSpeed / element.clientHeight;

          // Apply to pan offset
          this.panOffset.add(offset);
        }

        dolly(dollyScale) {
          if (dollyScale > 1) {
            this.scale /= dollyScale;
          } else {
            this.scale *= 1 / dollyScale;
          }
        }

        update() {
          const position = this.camera.position;
          const offset = position.clone().sub(this.target);

          // Apply panning
          if (this.panOffset.lengthSq() > 0) {
            // Need to adjust pan direction based on current camera rotation
            const rotMatrix = new THREE.Matrix4().extractRotation(this.camera.matrix);
            const pan = new THREE.Vector3(this.panOffset.x, this.panOffset.y, 0);
            pan.applyMatrix4(rotMatrix);
            this.target.add(pan);
            position.add(pan);
            this.panOffset.set(0, 0, 0);
          }

          // Convert to spherical coordinates
          this.spherical.setFromVector3(offset);

          // Apply zoom
          if (this.scale !== 1) {
            this.spherical.radius /= this.scale;
            this.scale = 1;
          }

          // Clamp zoom distance
          this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));

          // Apply rotation
          this.spherical.theta += this.sphericalDelta.theta;
          this.spherical.phi += this.sphericalDelta.phi;

          // Restrict phi to between 0.1 and PI - 0.1
          this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));
          this.spherical.makeSafe();

          // Update position
          offset.setFromSpherical(this.spherical);
          position.copy(this.target).add(offset);

          this.camera.lookAt(this.target);

          // Reset deltas
          this.sphericalDelta.set(0, 0, 0);

          return true;
        }
      }

      // Initialize scene, camera, and renderer
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(50, 50, 50);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // Controls
      const controls = new TouchControls(camera, renderer.domElement);

      // Lighting
      const light = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(light);
      const directional = new THREE.DirectionalLight(0xffffff, 0.8);
      directional.position.set(20, 40, 30);
      scene.add(directional);

      // Container wireframe
      const container = new THREE.BoxGeometry(40, 40, 40);
      const wireframe = new THREE.EdgesGeometry(container);
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
      const boxOutline = new THREE.LineSegments(wireframe, lineMaterial);
      boxOutline.position.set(20, 20, 20); // Center the container
      scene.add(boxOutline);

      // Get data from URL
      const urlParams = new URLSearchParams(window.location.search);
      let items = [];
      try {
        const dataParam = urlParams.get("data");
        if (dataParam) {
          // Try to parse as direct JSON
          try {
            items = JSON.parse(dataParam);
          } catch (e) {
            // If that fails, try to decode it first (for encoded URLs)
            try {
              items = JSON.parse(decodeURIComponent(dataParam));
            } catch (e2) {
              console.error("Failed to parse data after decoding", e2);
            }
          }
        }
        document.getElementById('itemCount').textContent = items.length;
      } catch (e) {
        console.error("Failed to parse query data", e);
        document.getElementById('itemCount').textContent = "Error";
      }

      // Create colored materials for boxes
      const colors = [
        0x3498db, // Blue
        0xe74c3c, // Red
        0x2ecc71, // Green
        0xf39c12, // Orange
        0x9b59b6, // Purple
        0x1abc9c, // Teal
        0xd35400, // Dark Orange
        0x34495e  // Dark Blue
      ];

      let meshes = [];

      // Create box meshes
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if (!item || item.length < 6) continue; // Skip invalid items

        const [x, y, z, w, h, d] = item;
        const geometry = new THREE.BoxGeometry(w, h, d);

        // Use a different color for each box
        const colorIndex = i % colors.length;
        const material = new THREE.MeshStandardMaterial({
          color: colors[colorIndex],
          transparent: true,
          opacity: 0.85
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x + w / 2, y + h / 2, z + d / 2);
        mesh.visible = false;
        scene.add(mesh);
        meshes.push(mesh);
      }

      // Animation controls
      let currentIndex = 0;
      let isPlaying = false;
      let interval;
      const animationSpeed = 300; // milliseconds between box appearances

      function updateCounter() {
        document.getElementById('currentItem').textContent =
          currentIndex + " / " + meshes.length;
      }

      function play() {
        if (isPlaying || currentIndex >= meshes.length) return;
        isPlaying = true;
        document.getElementById('play-button').style.backgroundColor = '#d4f7d4'; // Light green
        document.getElementById('pause-button').style.backgroundColor = '';
        interval = setInterval(() => {
          if (currentIndex < meshes.length) {
            meshes[currentIndex].visible = true;
            currentIndex++;
            updateCounter();
          } else {
            pause();
          }
        }, animationSpeed);
      }

      function pause() {
        isPlaying = false;
        clearInterval(interval);
        document.getElementById('play-button').style.backgroundColor = '';
        document.getElementById('pause-button').style.backgroundColor = '#f7d4d4'; // Light red
      }

      function rewind() {
        pause();
        for (let mesh of meshes) mesh.visible = false;
        currentIndex = 0;
        updateCounter();
        document.getElementById('pause-button').style.backgroundColor = '';
        document.getElementById('rewind-button').style.backgroundColor = '#d4d4f7'; // Light blue
        setTimeout(() => {
          document.getElementById('rewind-button').style.backgroundColor = '';
        }, 300);
      }

      // Wire up the control buttons
      document.getElementById('play-button').addEventListener('click', play);
      document.getElementById('pause-button').addEventListener('click', pause);
      document.getElementById('rewind-button').addEventListener('click', rewind);

      // Help button toggle
      document.getElementById('help-button').addEventListener('click', function () {
        const helpContent = document.getElementById('help-content');
        if (helpContent.style.display === 'block') {
          helpContent.style.display = 'none';
        } else {
          helpContent.style.display = 'block';
        }
      });

      // Initialize counter
      updateCounter();

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Remove loading screen when everything is ready
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
      }, 500);
    });
  </script>
</body>

</html>